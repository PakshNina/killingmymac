# Killing My Mac

Проект для тестирования поведения сборщика мусора и управления памятью в разных версиях Go.

## Описание

Проект содержит две версии программы, которые создают связанный список узлов в памяти для демонстрации работы сборщика мусора Go:

- `initial/main.go` - простая версия, создающая бесконечный связанный список без контроля памяти
- `withstat/main.go` - расширенная версия с мониторингом памяти, pprof сервером и автоматической остановкой при превышении лимита памяти

## Структура проекта

```
.
├── Dockerfile        # Единый Dockerfile с поддержкой разных версий Go
├── Makefile          # Команды для сборки и запуска
├── go.mod            # Go модуль
├── initial/          # Простая версия программы
│   └── main.go
└── withstat/         # Версия с мониторингом памяти
    └── main.go
```

## Требования

- Docker
- Make (опционально)

## Использование

### С помощью Make

Собрать Docker образ с Go 1.9.7:

```bash
make build19
```

Собрать и запустить контейнер с Go 1.9.7 (с ограничением памяти 500MB):

```bash
make run19
```

Собрать Docker образ с Go 1.12.1:

```bash
make build112
```

Собрать и запустить контейнер с Go 1.12.1 (с ограничением памяти 500MB):

```bash
make run112
```

Удалить все Docker образы:

```bash
make clean
```

### Без Make

Собрать образ с Go 1.9.7:

```bash
docker build -t kill-app --build-arg GO_VERSION=1.9.7 -f Dockerfile .
```

Запустить контейнер с Go 1.9.7 (с ограничением памяти):

```bash
docker run --rm -p 8080:8080 --memory=500m kill-app
```

Собрать образ с Go 1.12.1:

```bash
docker build -t normal-app --build-arg GO_VERSION=1.12.1 -f Dockerfile .
```

Запустить контейнер с Go 1.12.1 (с ограничением памяти):

```bash
docker run --rm -p 8080:8080 --memory=500m normal-app
```

## Мониторинг

При запуске версии `withstat/main.go` программа:

- Запускает pprof сервер на порту 8080
- Выводит статистику памяти каждые 1000000 созданных узлов
- Останавливается при превышении лимита в 1000MB памяти в куче
- Показывает количество сборок мусора

Программа выводит три метрики памяти:

- **Куча (HeapAlloc)** - память, выделенная Go runtime для объектов в куче
- **Стэк (StackInuse)** - память, используемая стеками горутин
- **Общая память (Sys)** - вся память, выделенная Go runtime (включая метаданные, страницы и т.д.)

Для доступа к pprof интерфейсу откройте в браузере:

```
http://localhost:8080/debug/pprof/
```

## Escape Analysis

Escape analysis (анализ утечки в кучу) - это процесс компилятора Go, который определяет, должны ли переменные размещаться на стеке или в куче. Переменные, которые "убегают" (escape) на кучу, увеличивают нагрузку на сборщик мусора.

Для анализа escape в коде используйте флаг `-m` компилятора:

```bash
go build -gcflags="-m" initial/main.go
```

Или для более подробного вывода:

```bash
go build -gcflags="-m -m" initial/main.go
```

Эта команда покажет:
- Какие переменные размещаются на куче (escape to heap)
- Причины, по которым переменные убегают на кучу
- Оптимизации, которые компилятор может применить

**Пример вывода:**
```
./main.go:9:6: can inline main
./main.go:10:13: new(Node) escapes to heap
```

Запуск через Makefile:
```bash
make escape
```

Это помогает понять, почему объекты размещаются в куче и как это влияет на производительность и использование памяти.

## Ограничение памяти

По умолчанию контейнеры запускаются с ограничением памяти 500MB. Это позволяет:

- Тестировать поведение программы при ограниченных ресурсах
- Наблюдать работу сборщика мусора под давлением памяти
- Предотвращать исчерпание памяти на хосте

При превышении лимита Docker может остановить контейнер (OOM kill, Error 137).
