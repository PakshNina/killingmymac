# Killing My Mac

Проект для тестирования поведения сборщика мусора и управления памятью в разных версиях Go.

## Описание

Проект содержит несколько версий программ для демонстрации работы сборщика мусора Go и оптимизаций управления памятью:

- `initial/main.go` - простая версия, создающая бесконечный связанный список без контроля памяти
- `withstat/main.go` - расширенная версия с мониторингом памяти, pprof сервером и автоматической остановкой при превышении лимита памяти
- `recomendation/first/` - примеры оптимизации: сравнение связанного списка на стеке vs массив
- `recomendation/second/` - примеры оптимизации: влияние указателей на escape-анализ

## Структура проекта

```
.
├── Dockerfile                    # Единый Dockerfile с поддержкой разных версий Go через build-arg
├── Makefile                      # Команды для сборки, запуска и бенчмарков
├── go.mod                        # Go модуль (go 1.24.0)
├── initial/                      # Простая версия программы
│   └── main.go
├── withstat/                     # Версия с мониторингом памяти
│   └── main.go
└── recomendation/                # Примеры оптимизаций с тестами
    ├── first/
    │   ├── main.go               # badLinkedList vs goodArray
    │   └── main_test.go          # Бенчмарки для сравнения
    └── second/
        ├── main.go               # BigWithPtr vs BigNoPtr
        └── main_test.go          # Бенчмарки для escape-анализа
```

## Требования

- Docker
- Go 1.24.0+ (для локальной разработки и тестов)
- Make (опционально)

## Использование

### Docker сборка

Проект использует единый Dockerfile, который поддерживает сборку для разных версий Go через build-аргумент `GO_VERSION`.

#### С помощью Make

Собрать Docker образ с Go 1.9.1:

```bash
make build19
```

Запустить контейнер с Go 1.9.1 (с ограничением памяти 500Мб):

```bash
make run19
```

Собрать Docker образ с Go 1.24.1:

```bash
make build124
```

Запустить контейнер с Go 1.24.1 (с ограничением памяти 500Мб):

```bash
make run124
```

#### Без Make

Собрать образ с Go 1.9.1:

```bash
docker build --build-arg GO_VERSION=1.9.1 -t kill-app -f Dockerfile .
```

Запустить контейнер с Go 1.9.1 (с ограничением памяти):

```bash
docker run --rm -p 8080:8080 --memory=500m kill-app
```

Собрать образ с Go 1.24.1:

```bash
docker build --build-arg GO_VERSION=1.24.1 -t normal-app -f Dockerfile .
```

Запустить контейнер с Go 1.24.1 (с ограничением памяти):

```bash
docker run --rm -p 8080:8080 --memory=500m normal-app
```

### Локальные тесты и бенчмарки

Запустить бенчмарки для первого примера оптимизации:

```bash
make benchmark_1
```

Запустить бенчмарки для второго примера оптимизации:

```bash
make benchmark_2
```

Запустить все бенчмарки:

```bash
make benchmark
```

Анализ escape-анализа для второго примера:

```bash
make reflect_2
```

Или напрямую через go test:

```bash
# Бенчмарки первого примера
go test -bench=. -benchmem ./recomendation/first/

# Бенчмарки второго примера
go test -bench=. -benchmem ./recomendation/second/

# Escape-анализ для второго примера
go test ./recomendation/second -run=^$ -bench=^$ -gcflags="-m"
```

## Мониторинг

При запуске версии `withstat/main.go` программа:

- Запускает pprof сервер на порту 8080
- Выводит статистику памяти каждые 1000000 созданных узлов
- Останавливается при превышении лимита в 1000MB памяти в куче
- Показывает количество сборок мусора

Для доступа к pprof интерфейсу откройте в браузере:

```
http://localhost:8080/debug/pprof/
```

## Ограничение памяти

Команды `make run19` и `make run124` автоматически запускают контейнеры с ограничением памяти 500Мб. Это позволяет:

- Тестировать поведение программы при ограниченных ресурсах
- Наблюдать работу сборщика мусора под давлением памяти
- Предотвращать исчерпание памяти на хосте

При превышении лимита Docker может остановить контейнер (OOM kill, Error 137).

Если вы запускаете контейнеры напрямую через `docker run`, не забудьте добавить флаг `--memory=500m`:

```bash
docker run --rm -p 8080:8080 --memory=500m kill-app
```

## Примеры оптимизаций

### Первый пример (`recomendation/first/`)

Демонстрирует разницу между созданием связанного списка на стеке (`badLinkedList`) и использованием массива (`goodArray`). Массив создает только один объект на стеке вместо тысячи.

### Второй пример (`recomendation/second/`)

Показывает влияние указателей на escape-анализ. Структура с указателем (`BigWithPtr`) может уйти в кучу, в то время как структура без указателя (`BigNoPtr`) может остаться на стеке.

